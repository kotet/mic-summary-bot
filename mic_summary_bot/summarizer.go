package micsummarybot

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path"
	"strings"
	"text/template"
	"time"

	"github.com/google/uuid"
	"google.golang.org/genai"
)

type DocumentSummary struct {
	Summary   string   `json:"summary"`
	Metadata  string   `json:"metadata"`
	KeyPoints []string `json:"keyPoints"`
}

type SummarizeResult struct {
	Documents    []DocumentSummary `json:"documents"`
	Omissibles   []string          `json:"omissibles"`
	FinalSummary string            `json:"final_summary"`
}

// downloadFile は指定されたURLからファイルをダウンロードし、指定されたローカルパスに保存します。
func downloadFile(url string, filepath string) error {
	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	// Write the body to file
	_, err = io.Copy(out, resp.Body)
	return err
}

// SummarizeDocument はHTMLandDocumentsを要約します。
func (client *GenAIClient) SummarizeDocument(htmlAndDocs *HTMLandDocuments, promptTemplate string) (SummarizeResult, error) {
	ctx := context.Background()

	// モデル設定（構造化出力）
	modelConfig := &genai.GenerateContentConfig{
		Temperature:      new(float32), // 0
		ResponseMIMEType: "application/json",
		ResponseSchema: &genai.Schema{
			Type: genai.TypeObject,
			Properties: map[string]*genai.Schema{
				"documents": {
					Type: genai.TypeArray,
					Items: &genai.Schema{
						Type: genai.TypeObject,
						Properties: map[string]*genai.Schema{
							"metadata": {
								Type: genai.TypeString,
							},
							"keyPoints": {
								Type: genai.TypeArray,
								Items: &genai.Schema{
									Type: genai.TypeString,
								},
							},
							"summary": {
								Type: genai.TypeString,
							},
						},
						PropertyOrdering: []string{"metadata", "keyPoints", "summary"},
					},
				},
				"omissibles": {
					Type: genai.TypeArray,
					Items: &genai.Schema{
						Type: genai.TypeString,
					},
				},
				"final_summary": {
					Type: genai.TypeString,
				},
			},
			PropertyOrdering: []string{"documents", "omissibles", "final_summary"},
			Required:         []string{"final_summary"},
		},
	}

	t, err := template.New("prompt").Parse(promptTemplate)
	if err != nil {
		return SummarizeResult{}, fmt.Errorf("failed to parse prompt template: %w", err)
	}
	promptBuilder := &strings.Builder{}
	err = t.Execute(promptBuilder, struct{}{})
	if err != nil {
		return SummarizeResult{}, fmt.Errorf("failed to execute prompt template: %w", err)
	}
	prompt := promptBuilder.String()
	if prompt == "" {
		return SummarizeResult{}, fmt.Errorf("prompt is empty")
	}

	parts := []*genai.Part{}
	parts = append(parts, &genai.Part{
		InlineData: &genai.Blob{
			MIMEType: "text/html",
			Data:     htmlAndDocs.HTMLContent,
		},
	})

	err = os.MkdirAll(client.DownloadDir, 0755)
	if err != nil {
		return SummarizeResult{}, fmt.Errorf("failed to create download directory: %w", err)
	}

	for _, doc := range htmlAndDocs.Documents {
		if doc.Size > 50*1024*1024 {
			continue
		}
		id := uuid.New().String()
		ext := path.Ext(doc.URL)
		ext = strings.ToLower(ext)
		if ext != ".pdf" {
			continue
		}
		localPath := path.Join(client.DownloadDir, fmt.Sprintf("%s.pdf", id))
		err = downloadFile(doc.URL, localPath)
		if err != nil {
			return SummarizeResult{}, fmt.Errorf("failed to download file: %w", err)
		}
		f, err := client.Client.Files.UploadFromPath(ctx, localPath, &genai.UploadFileConfig{})
		if err != nil {
			return SummarizeResult{}, fmt.Errorf("failed to upload file: %w", err)
		}
		parts = append(parts, genai.NewPartFromURI(f.URI, f.MIMEType))
		if !client.KeepLocalCopy {
			os.Remove(localPath)
		}
	}

	parts = append(parts, genai.NewPartFromText(prompt))
	for i, part := range parts {
		pkgLogger.Debug("parts created", "index", i, "part", part)
	}

	contents := []*genai.Content{genai.NewContentFromParts(parts, genai.RoleUser)}

	// LLMへのリクエストとリトライ処理
	var resp *genai.GenerateContentResponse
	for i := 0; i < client.MaxRetry+1; i++ {
		resp, err = client.Client.Models.GenerateContent(ctx, client.SummarizingModel, contents, modelConfig)
		if err == nil {
			break // 成功したらループを抜ける
		}
		pkgLogger.Warn("Gemini API call failed", "attempt", i+1, "max_retry", client.MaxRetry+1, "error", err, "retrying_in_seconds", client.RetryIntervalSec)
		time.Sleep(time.Duration(client.RetryIntervalSec) * time.Second)
	}

	if err != nil {
		return SummarizeResult{}, fmt.Errorf("failed to get response from Gemini API after %d retries: %w", client.MaxRetry, err)
	}

	// レスポンスのパース
	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return SummarizeResult{}, fmt.Errorf("no content generated by Gemini API")
	}

	// LLMの応答をテキストとして取得
	responseText := resp.Text()

	pkgLogger.Debug("Gemini API response", "response", responseText)

	var jsonResult SummarizeResult
	err = json.Unmarshal([]byte(responseText), &jsonResult)
	if err != nil {
		return SummarizeResult{}, fmt.Errorf("failed to parse JSON response from Gemini API: %w", err)
	}

	return jsonResult, nil
}
